#include "app.h"
#include <stdio.h>
#include "adc.h"

//===========================================================
//----------Œ¬∂»±Ì∏Ò
static const unsigned int temptab[]={  //0 to 100°Ê 
	2809, 2764, 2718, 2671, 2625, 2577, 2530, 2482, 2434, 2386, //0-9
  2337, 2289, 2241, 2193, 2145, 2097, 2049, 2002, 1955, 1908,
  1862, 1816, 1771, 1726, 1682, 1638, 1595, 1553, 1512, 1471,
  1431, 1391, 1353, 1315, 1278, 1241, 1206, 1171, 1137, 1104,
  1072, 1040, 1009, 979, 950, 922, 894, 867, 841, 815,
  791, 767, 743, 721, 699, 677, 657, 636, 617, 598,
  580, 562, 545, 528, 512, 496, 481, 467, 452, 439,
  425, 412, 400, 388, 376, 365, 354, 343, 333, 323,
  313, 304, 295, 286, 278, 270, 262, 254, 247, 240,
  233, 226, 220, 213, 207, 201, 196, 190, 185, 180	//90-99
}; 

#ifdef ENABLE_DEBUG_DISPLAY
enum{
	A1=0,
	B1,
	C1,
	D1,
	E1,
	F1,
	G1,
	H1,
	A2,
	B2,
	C2,
	D2,
	E2,
	F2,
	G2
};

const uint8_t DotDecode[][10] = {
//        Dr1_dir        Dr1        
/*A1*/ {GPIO_MODE_OUTPUT_PP, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_INPUT, GPIO_MODE_INPUT,  1,0,0,0,0},
/*B1*/ {GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_INPUT,  1,0,0,0,0},
/*C1*/ {GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT,  1,0,0,0,0},
/*D1*/ {GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_INPUT, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP,  1,0,0,0,0},
/*E1*/ {GPIO_MODE_OUTPUT_PP, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_INPUT, GPIO_MODE_INPUT,  0,1,0,0,0},
/*F1*/ {GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_INPUT,  0,1,0,0,0},
/*G1*/ {GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP,  0,1,0,0,0},  //DuFeiPeng design board
/*H1*/ {GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT,  0,1,0,0,0},   //DuFeiPeng design board
/*A2*/ {GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_INPUT,  0,0,1,0,0},
/*B2*/ {GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_INPUT,  0,0,1,0,0},
/*C2*/ {GPIO_MODE_INPUT, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT,  0,0,1,0,0},
/*D2*/ {GPIO_MODE_INPUT, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP,  0,0,1,0,0},
/*E2*/ {GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT,  0,0,0,1,0},
/*F2*/ {GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT,  0,0,0,1,0},
/*G2*/ {GPIO_MODE_INPUT, GPIO_MODE_INPUT, GPIO_MODE_OUTPUT_PP, GPIO_MODE_OUTPUT_PP, GPIO_MODE_INPUT,  0,0,0,1,0}
};

const uint8_t Segment_Code[]={
//HGFEDCBA
0x3F, // 0B00111111 (0)   1:led light on 0:led light off
0x06, // 0B00000110 (1)
0x5B, // 0B01011011 (2)
0x4F, // 0B01001111 (3)
0x66, // 0B01100110 (4)
0x6D, // 0B01101101 (5)
0x7D, // 0B01111101 (6)
0x07, // 0B00000111 (7)
0x7F, // 0B01111111 (8)
0x6F, // 0B01101111 (9)
0x00, // 0B00000000 (A)
0x00, // 0B00000000 (B)
0x00, // 0B00000000 (C)
0x00, // 0B00000000 (D)
0x79, // 0B01111001 (E)
0x00 	// 0B00000000 (F)
};
#endif

key key_child_lock = {
	KEY_CHILD_LOCK,
	KEY_UP,
	EVT_NUM,
	CHILD_LOCK_PRESS_EVT,
    0
	} ,	\
	key_temper_chg = {
	KEY_TEMPER_CHG,
	KEY_UP,
	TEMPER_CHG_EVT,
	TEMPER_CHG_EVT,
    0
	} , \
	key_water_out= {
	KEY_WATER_OUT,
	KEY_UP,
	EVT_NUM,
	WATER_OUT_PRESS_EVT,
    0
	}  , \
	key_pre_heat = {
	KEY_PRE_HEAT,
	KEY_UP,
	PRE_HEAT_PRESS_EVT,
	PRE_HEAT_PRESS_EVT,
    0
	} , \
	key_disinfect= {
	 KEY_DISINFECT,
	 KEY_UP,
     DISINFECTION_PRESS_EVT,
	 DISINFECTION_PRESS_EVT,
    0
	} ;

led led_tbl[] = {
	{LED_ID_CHILD_LOCK,   LED_ON},
	{LED_ID_TEMPER_CHG,  LED_OFF},
	{LED_ID_WATER_OUT,   LED_OFF},
	{LED_ID_PRE_HEAT,    LED_OFF},
	{LED_ID_DISINFECT,   LED_OFF}};

alarm mAlarm;
WaterDispenser mDispenser;
	
#ifdef ENABLE_DEBUG_PTC
ptc ptc_in,ptc_out;
#define NUM_ADC_CHANNEL 2
uint32_t adc_value[2];
#endif
	
pulse_counter iFlow;

volatile uint16_t Flow_Value = 0;

// PIDøÿ÷∆≤Œ ˝
#define PID_KP 2.0
#define PID_KI 0.1
#define PID_KD 0.5
volatile int pid_error = 0;
volatile int pid_last_error = 0;
volatile int pid_integral = 0;
int pid_output = 0;

volatile unsigned char heating_enabled = 0;        // º”»»∆Ù”√◊¥Ã¨
volatile unsigned char heating_pwr = 0;        // º”»»power
volatile unsigned char heating_cnt = 0;               // ’ºø’±»º∆ ˝÷µ£®0-10£©
volatile unsigned char pump_speed = 0;             // ÀÆ±√ÀŸ∂»(0-100%)
volatile unsigned char pump_cnt = 0;               // ’ºø’±»º∆ ˝÷µ£®0-5£©

uint8_t AlarmTimeBase_1s = 0; //1s alarm base time  flag
uint8_t KeyTimeBase_20ms = 0;  //20ms key base time  flag
uint8_t LedTimeBase_500ms = 0;  //20ms key base time  flag
uint16_t time_cnt_1s = 0;
uint16_t time_cnt_500ms = 0;
uint16_t time_cnt_10ms = 0;


uint8_t target_temper_tbl[] = {25,45,55,85,95};

void System_Init(void)
{

	mDispenser.temper_index =0;
	mDispenser.CurrentState = STATE_CHILD_LOCK;
	mDispenser.temp_setting = target_temper_tbl[mDispenser.temper_index];
	mDispenser.disinfect_finish_flag = ON;

	#ifdef ENABLE_DEBUG_PTC    
	ptc_in.channel = 1;
	ptc_out.channel = 18;
	#endif
	
	heating_enabled = 0;
	heating_pwr = 30; 
	pump_speed = 60;
	set_led_status(LED_ID_CHILD_LOCK,LED_ON);
	set_all_leds_status(LED_ON,LED_OFF,LED_OFF,LED_OFF,LED_OFF);
}

void waterout_process(void)
{
	heating_enabled = 1;
		HAL_GPIO_WritePin(HEATER,OFF);
    pump_speed = 100;
	
#ifdef ENABLE_DEBUG_PID	
  	calculate_pid();
#endif
}
void preheat_process(void)
{
	heating_enabled = 1;
	pump_speed = 100;
	
	#ifdef ENABLE_DEBUG_PID
	calculate_pid();
	#endif
}
void disinfect_process(void)
{
	if(mDispenser.disinfect_finish_flag == 0)
	{
    heating_enabled = 1;
    pump_speed = 100;
		#ifdef ENABLE_DEBUG_PID
     calculate_pid();
		#endif
	}else
    {
		heating_enabled = 0;
        pump_speed = 100;
    } 

	if(mDispenser.disinfect_clr_water_flag == 1)  //Ω¯––≈≈ø’ÀÆ
	{
		pump_speed = 100;
    }else  pump_speed = 0;						
}

void loop_fun(void)
 {
	switch(mDispenser.CurrentState)
    {
		case STATE_IDLE:
					heating_enabled = 0;
					HAL_GPIO_WritePin(HEATER,OFF);
					pump_speed = 0;
				break;

		case STATE_CHILD_LOCK:
            heating_enabled = 0;
            HAL_GPIO_WritePin(HEATER,OFF);
            pump_speed = 60;
        	break;
		
		case STATE_WATER_OUT:
			waterout_process();
        	break;
		
		case STATE_PRE_HEAT:
			preheat_process();
        	break;
		
		case STATE_DISINFECT:
			disinfect_process();
        	break;
		
    default :
        	break;
    }
 }

void disinfect_alarm_timeout(void)
{
	mDispenser.disinfect_finish_flag = 1;
	set_led_status(LED_ID_WATER_OUT,LED_BLINK);
	set_led_status(LED_ID_DISINFECT,LED_ON);
}

const alarm_cb alarm_cb_tbl[]=
{
	disinfect_alarm_timeout
};

void Alarm_Start(alarm *alarm,uint8_t hh,uint8_t mm,uint8_t ss,uint8_t type_flag)
 {
	if(!((hh ==0) && ( mm ==0) && (ss == 0)))
    {
		alarm->hh = hh;
		alarm->mm = mm;
		alarm->ss = ss;
		alarm->type_flag = type_flag;
		alarm->state = ON;
		alarm->alarm_timeout_cb = alarm_cb_tbl[type_flag];
	printf("start a alarm  hh:mm:ss  %d:%d:%d\n",mAlarm.hh,mAlarm.mm,mAlarm.ss);
	}
 }
 
void Alarm_Cancel(alarm *alarm)
 {
	if(alarm->state != OFF){
    	alarm->hh = 0;
		alarm->mm = 0;
		alarm->ss = 0;
		alarm->type_flag = 0;
		alarm->state = OFF;
		printf("cancel timer \n");
    }else printf("Alarm_Cancel:alarm don't exist \n");
 }
 
void Alarm_Process(void)
 {

	if((AlarmTimeBase_1s==1)&&(mAlarm.state == ON)&&(mAlarm.hh > 0 || mAlarm.mm > 0 || mAlarm.ss > 0))
    {
		if(mAlarm.ss > 0) {
			mAlarm.ss--;
		} else {
			if(mAlarm.mm > 0) {
				mAlarm.mm--;
				mAlarm.ss = 59;
			} else {
				if(mAlarm.hh > 0) {
					mAlarm.hh--;
					mAlarm.mm = 59;
					mAlarm.ss = 59;
				}                     	 
			}
		}
		
		if((mAlarm.hh == 0 && mAlarm.mm == 0 && mAlarm.ss == 0))
		{
			if(mAlarm.alarm_timeout_cb) mAlarm.alarm_timeout_cb();
			 mAlarm.state = OFF;
			 mAlarm.alarm_timeout_cb = NULL;
		}

		if(mAlarm.state == ON)
		{
			printf("alarm time remain hh:mm:ss  %d:%d:%d\n",mAlarm.hh,mAlarm.mm,mAlarm.ss);
		}

		printf("alarm state : %d \n",mAlarm.state);
        AlarmTimeBase_1s = 0;    
    }
 }

void alarm_cb_demo(void)
{
	printf("alarm timeout :mAlarm.type_flag: %d \n",mAlarm.type_flag);
}

int get_key_io_level(uint8_t key_index)
{
	int ret = 1;
	switch (key_index)
	{
		case KEY_CHILD_LOCK:      
				 ret = HAL_GPIO_ReadPin(LOCK_KEY);
		break;

    case KEY_TEMPER_CHG:        
				 ret = HAL_GPIO_ReadPin(TEMP_CHG_KEY);
		break;

    case KEY_WATER_OUT:        
				 ret = HAL_GPIO_ReadPin(WATEROUT_KEY);
		break;

    case KEY_PRE_HEAT:         
				 ret = HAL_GPIO_ReadPin(PREHEAT_KEY);
		break;

	case KEY_DISINFECT:    		
		ret = HAL_GPIO_ReadPin(DISINFECT_KEY);
		break;
	
	default:
		break;
	}

	return ret;
}

void single_key_Scan(key* _key)  
 {
	if(get_key_io_level(_key->id) == 0 ) //get key down state
	{
		_key->status = KEY_DOWN;
    _key->press_time++;        
  }
  else
  {
		if(_key->press_time >= LONG_PRESS_TIME/10)
    {
			_key->status = KEY_LONG_PRESS;
    }else if(_key->press_time >= SHORT_PRESS_TIME/10)
    {
			_key->status = KEY_SHORT_PRESS;
    }
    _key->press_time=0;
  }       
 }

void Keys_Scan(void)
{
	single_key_Scan(&key_child_lock);
	single_key_Scan(&key_temper_chg);
	single_key_Scan(&key_water_out);
	single_key_Scan(&key_pre_heat);
	single_key_Scan(&key_disinfect);
}

void Key_status_handler(key* _key)
{
	switch(_key->status){
    case KEY_SHORT_PRESS:
		if(_key->short_press_event != EVT_NUM)
		{
			WaterDispenser_Eventhandler(&mDispenser,_key->short_press_event);
		}
		break;
        
    case KEY_LONG_PRESS:
		if(_key->long_press_event != EVT_NUM)
		{
			WaterDispenser_Eventhandler(&mDispenser,_key->long_press_event);
		}
		break;
    default :break;
    }
    _key->status = KEY_UP;
}

void Keys_handler(void)
{
	Key_status_handler(&key_child_lock);
	Key_status_handler(&key_temper_chg);
	Key_status_handler(&key_water_out);
	Key_status_handler(&key_pre_heat);
	single_key_Scan(&key_disinfect);
}

/************    ****************/
void set_led_status(uint8_t led_index,uint8_t status)
{
	led_tbl[led_index].status = status;
	switch (led_tbl[led_index].id)
	{
		case LED_ID_CHILD_LOCK:     // Á´•ÈîÅ
				 HAL_GPIO_WritePin(LOCK_LED,status);
			   break;
		
		case LED_ID_TEMPER_CHG:        // Ë∞ÉÊ∏©
				 HAL_GPIO_WritePin(TEMP_CHG_LED,status);
				 break;
		
		case LED_ID_WATER_OUT:         // Âá∫Ê∞¥
				 HAL_GPIO_WritePin(WATEROUT_LED,status);
			break;
		
		case LED_ID_PRE_HEAT:          // È¢ÑÂä†ÁÉ≠
			   HAL_GPIO_WritePin(PREHEAT_LED,status);
			break;
		
		case LED_ID_DISINFECT:    		//Ê∂àÊØí:
				HAL_GPIO_WritePin(DISINFECT_LED,status);
			break;
		
		default:
			break;
	}
}

void set_all_leds_status(uint8_t led1_sta,uint8_t led2_sta,uint8_t led3_sta,uint8_t led4_sta,uint8_t led5_sta)
{
		set_led_status(LED_ID_CHILD_LOCK,led1_sta);
    set_led_status(LED_ID_TEMPER_CHG,led2_sta);
    set_led_status(LED_ID_WATER_OUT,led3_sta);
    set_led_status(LED_ID_PRE_HEAT,led4_sta);
    set_led_status(LED_ID_DISINFECT,led5_sta);
}

void led_blink(void)
{
	uint8_t LED_index = 0;
	if(LedTimeBase_500ms == 1 )
	{	
		LedTimeBase_500ms = 0;
//		printf("LED_id %d  status %d\n",led_tbl[LED_CHILD_LOCK].id,led_tbl[LED_CHILD_LOCK].status);
		for(LED_index = 0 ; LED_index < LED_ID_NUM ; LED_index++)
		{
			if(led_tbl[LED_index].status == LED_BLINK)
			{
				switch (LED_index)
				{
				case LED_ID_CHILD_LOCK:     // 
						 HAL_GPIO_TogglePin(LOCK_LED);
						 break;
				
    		case LED_ID_TEMPER_CHG:        // 
						 HAL_GPIO_TogglePin(TEMP_CHG_LED);
					break;
				
 				case LED_ID_WATER_OUT:         //
					   HAL_GPIO_TogglePin(WATEROUT_LED);
					break;
				
			  case LED_ID_PRE_HEAT:          // 
					   HAL_GPIO_TogglePin(PREHEAT_LED);
					break;
					
				case LED_ID_DISINFECT:    		//
						 HAL_GPIO_TogglePin(DISINFECT_LED);
					break;
				
				default:
					break;
				}
			}
		}
	}
	
}

void DelayUs(uint32_t us) 
{
	if (us >= 1000) {
			HAL_Delay(us / 1000);  
			us %= 1000; 
	}
	for (uint32_t i = 0; i < us * 8; i++) {
			__NOP();
	}
}

#ifdef ENABLE_DEBUG_DISPLAY
void display(void)
{
	uint8_t i,j,time=50;
    
	//display tens place
	for(i=A1;i<=H1;i++)
  {
		if(((Segment_Code[mDispenser.temp_setting/10]>>i)&0x01) == 1)   //for a number ,if corresponding bit is 1,the segment should be light up
    {
			GPIO_CONFIG(Dr1_group,Dr1,DotDecode[i][0],DotDecode[i][5]); 
			GPIO_CONFIG(Dr2_group,Dr2,DotDecode[i][1],DotDecode[i][6]);
			GPIO_CONFIG(Dr3_group,Dr3,DotDecode[i][2],DotDecode[i][7]);
			GPIO_CONFIG(Dr4_group,Dr4,DotDecode[i][3],DotDecode[i][8]);
			GPIO_CONFIG(Dr5_group,Dr5,DotDecode[i][4],DotDecode[i][9]);
			DelayUs(time);
			GPIO_SET_LOW(Dr1_group,Dr1); //turn all led off,or unexpected led light up
			GPIO_SET_LOW(Dr2_group,Dr2);
			GPIO_SET_LOW(Dr3_group,Dr3);
			GPIO_SET_LOW(Dr4_group,Dr4);
			GPIO_SET_LOW(Dr5_group,Dr5);         
    }      
  }
		
  //display units place
	for(i=A1;i<=G1;i++)
	{
		if(((Segment_Code[mDispenser.temp_setting%10]>>i)&0x01) == 1)
		{
			j=i+8;
			GPIO_CONFIG(Dr1_group,Dr1,DotDecode[j][0],DotDecode[j][5]); 
			GPIO_CONFIG(Dr2_group,Dr2,DotDecode[j][1],DotDecode[j][6]);
			GPIO_CONFIG(Dr3_group,Dr3,DotDecode[j][2],DotDecode[j][7]);
			GPIO_CONFIG(Dr4_group,Dr4,DotDecode[j][3],DotDecode[j][8]);
			GPIO_CONFIG(Dr5_group,Dr5,DotDecode[j][4],DotDecode[j][9]);
			DelayUs(time);
			GPIO_SET_LOW(Dr1_group,Dr1); //turn all led off,or unexpected led light up
			GPIO_SET_LOW(Dr2_group,Dr2);
			GPIO_SET_LOW(Dr3_group,Dr3);
			GPIO_SET_LOW(Dr4_group,Dr4);
			GPIO_SET_LOW(Dr5_group,Dr5); 
    }
	}
	
	//Display Temperature Indicator
	GPIO_CONFIG(Dr1_group,Dr1,DotDecode[H1][0],DotDecode[H1][5]); 
	GPIO_CONFIG(Dr2_group,Dr2,DotDecode[H1][1],DotDecode[H1][6]);
	GPIO_CONFIG(Dr3_group,Dr3,DotDecode[H1][2],DotDecode[H1][7]);
	GPIO_CONFIG(Dr4_group,Dr4,DotDecode[H1][3],DotDecode[H1][8]);
	GPIO_CONFIG(Dr5_group,Dr5,DotDecode[H1][4],DotDecode[H1][9]);
	DelayUs(time);
	GPIO_SET_LOW(Dr1_group,Dr1); //turn all led off,or unexpected led light up
	GPIO_SET_LOW(Dr2_group,Dr2);
	GPIO_SET_LOW(Dr3_group,Dr3);
	GPIO_SET_LOW(Dr4_group,Dr4);
	GPIO_SET_LOW(Dr5_group,Dr5);
}
#endif

#ifdef ENABLE_DEBUG_PTC
void get_ptc_temper(ptc _ptc)
{ 
	float sum = 0;
	uint16_t adc_value;
	int i,temper;
 
	/*******get adc temper value*******/   
	HAL_ADC_Start(&hadc);//??ADC1
	HAL_ADC_PollForConversion(&hadc,10);//??????
	adc_value = HAL_ADC_GetValue(&hadc);//??ADC??
	for(temper=0;temper<100;temper++)
	{	
		if(temper>=99)temper = 99;			//◊Ó¥Û≤ÈµΩ100
		if(adc_value >= temptab[temper]){	    //»Áπ˚AD◊™ªª÷µ¥Û”⁄ªÚµ»”⁄≤È±Ì÷µ£¨ªÒ»°Œ¬∂»÷Æ∫Û÷±Ω”÷’÷π				
			break;				//ªÒ»°µΩŒ¬∂» ˝÷µ∫Û÷’÷π—≠ª∑
		}
	}     
	/*******moving window filter calculator average temper value*******/
	_ptc.buffer[_ptc.buffer_id]=temper;
	_ptc.buffer_id = (++_ptc.buffer_id) % WINDOW_SIZE;
	for(i=0;i<WINDOW_SIZE;i++) sum += _ptc.buffer[i];
	_ptc.temper = sum/WINDOW_SIZE;
}

/**
 * ADC_Get_Value
 **/
void ADC_Get_Value(void)
{
	get_ptc_temper(ptc_in);
	get_ptc_temper(ptc_out);
	HAL_ADC_Stop(&hadc);
}

#endif

#ifdef ENABLE_DEBUG_PID
// PIDøÿ÷∆∆˜º∆À„
void calculate_pid(void)
{
    // º∆À„ŒÛ≤Ó
    pid_error = mDispenser.temp_setting - ptc_out.temper;
    
    // º∆À„ª˝∑÷œÓ
    pid_integral += pid_error;
    
    // œﬁ÷∆ª˝∑÷œÓ£¨∑¿÷πª˝∑÷±•∫Õ
    if (pid_integral > 100) pid_integral = 100;
    if (pid_integral < -100) pid_integral = -100;
    
    // º∆À„Œ¢∑÷œÓ
    int derivative = pid_error - pid_last_error;
    
    // º∆À„PID ‰≥ˆ
    pid_output = (PID_KP * pid_error) + (PID_KI * pid_integral) + (PID_KD * derivative);
    
    // œﬁ÷∆ ‰≥ˆ∑∂Œß
    if (pid_output > 100) pid_output = 100;
    if (pid_output < 0) pid_output = 0;
    heating_pwr = pid_output;
    // ∏¸–¬…œ“ª¥ŒŒÛ≤Ó
    pid_last_error = pid_error;
}


void safety_check(void)
{
    // ≥¨Œ¬±£ª§
    if (ptc_out.temper > 98) {
        // πÿ±’º”»»∫ÕÀÆ±√
        heating_enabled = 0;
        pump_speed = 0;// πÿ±’ÀÆ±√
        HAL_GPIO_WritePin(PUMP,OFF);// πÿ±’ÀÆ±√ 
        HAL_GPIO_WritePin(HEATER,OFF);// πÿ±’º”»»π‹
        
//        // ±®æØ
//        beep(5);
        // «–ªªµΩø’œ–◊¥Ã¨
        mDispenser.CurrentState = STATE_IDLE;
    }
    
    // »±ÀÆ±£ª§(Œﬁ¡˜¡øµ´º”»»ø™∆Ù)
    if (heating_enabled && iflow_HZ < 32) {
        // πÿ±’º”»»
        heating_enabled = 0;
        pump_speed = 0;// πÿ±’ÀÆ±√
        HAL_GPIO_WritePin(PUMP,OFF);// πÿ±’ÀÆ±√ 
        HAL_GPIO_WritePin(HEATER,OFF);// πÿ±’º”»»π‹
        // ±®æØ
    }
}
#endif
